{"dependencies":[{"name":"C:\\Users\\david\\code\\dimensions\\frontend2\\tsconfig.json","includedInParent":true,"mtime":1530931500191},{"name":"C:\\Users\\david\\code\\dimensions\\frontend2\\package.json","includedInParent":true,"mtime":1530932540296}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n// Vertex shader program\nvar vsSource = exports.vsSource = \"\\n    attribute vec4 a_position;\\n    attribute vec4 a_normal;\\n                   \\n    // We can't pass 5x5 homogenous matrices to the shader, but can pass 4x4,\\n    // non-homogenous matrices, then translate separately.\\n    uniform mat4 u_model;\\n    uniform mat4 u_view;\\n    uniform mat4 u_proj;\\n    \\n    uniform vec4 u_shape_position;\\n    uniform vec4 u_cam_position;\\n    uniform vec4 u_ambient_light_color;\\n    uniform vec4 u_diffuse_light_color;\\n    uniform vec4 u_diffuse_light_direction;\\n    \\n    uniform float u_ambient_intensity;\\n    uniform float u_specular_intensity;\\n    uniform float u_color_max;\\n           \\n    varying vec4 v_fourd_color;\\n    varying vec4 v_diffuse;\\n    varying vec4 v_specular;\\n\\n    void main() {\\n        // For model transform, position after the transform\\n        vec4 positionedPt = (u_model * a_position) + u_shape_position;\\n        // for view transform, position first.\\n        positionedPt = u_view * (positionedPt - u_cam_position);\\n        \\n        // Now remove the u coord; replace with 1. We no longer need it, \\n        // and the projection matrix is set up for 3d homogenous vectors.\\n        vec4 positioned3d = vec4(positionedPt[0], positionedPt[1], positionedPt[2], 1.);\\n        \\n        gl_Position = u_proj * positioned3d;\\n      \\n      \\n        // Now calculate the color, based on passed u dist from cam.\\n        float u_dist = u_cam_position[3] - positionedPt[3];\\n        \\n        float portion_through = abs(u_dist) / u_color_max;\\n\\n        if (portion_through > 1.) {\\n            portion_through = 1.;\\n        }\\n        \\n        float base_gray = 0.0;\\n        float color_val = base_gray + portion_through;\\n        \\n        vec4 f_color;\\n        if (u_dist > 0.) {\\n            f_color = vec4(base_gray, base_gray, color_val, 0.2);  // Blue\\n        } else {\\n            f_color = vec4(color_val, base_gray, base_gray, 0.2);  // Red\\n        }\\n        \\n        vec4 v_fourd_color = f_color * u_ambient_intensity;\\n        \\n        // Process diffuse lighting from a single-directional source.\\n        // We can use the model matrix directly on the normal, since it\\n        // only scales uniformly, and isn't homogenous (doesn't translate).\\n        vec4 norm = normalize(u_model * a_normal);\\n        vec4 dir = normalize(u_diffuse_light_direction);\\n        float directional_light_weight = max(dot(norm, dir), 0.);\\n\\n        v_diffuse = u_diffuse_light_color * directional_light_weight;\\n\\n        v_specular = vec4(0., 0., 0., 0.);  // todo\\n\\n//         // Now calculate specular lighting.\\n//         // todo deal with view trasnforms.\\n//         vec4 view_dir = normalize(u_cam_position - a_position);\\n// //        vec4 view_dir = normalize(uview * (u_cam_position - a_position));\\n//         vec4 reflect_dir = reflect(-dir, norm);\\n// //        vec4 reflect_dir = u_view * reflect(-dir, norm);\\n//         float spec = pow(max(dot(view_dir, reflect_dir), 0.), 32.);\\n//         v_specular = u_specular_intensity * spec * u_diffuse_light_color;\\n    }\\n\";\n// Fragment shader program\nvar fsSource = exports.fsSource = \"\\n    varying highp vec4 v_fourd_color;\\n    varying highp vec4 v_diffuse;\\n    varying highp vec4 v_specular;\\n\\n    void main() {\\n        gl_FragColor = v_fourd_color + v_diffuse;\\n    }\\n\";\nvar vsSkybox = exports.vsSkybox = \"\\n    attribute vec4 a_position;\\n    attribute vec2 a_texcoord;\\n     \\n    uniform mat4 u_matrix;\\n     \\n    varying vec2 v_texcoord;\\n     \\n    void main() {\\n      // Multiply the position by the matrix.\\n      gl_Position = u_matrix * a_position;\\n     \\n      // Pass the texcoord to the fragment shader.\\n      v_texcoord = a_texcoord;\\n    }\\n\";\nvar fsSkybox = exports.fsSkybox = \"\\n        precision mediump float;\\n         \\n        // Passed in from the vertex shader.\\n        varying vec2 v_texcoord;\\n         \\n        // The texture.\\n        uniform sampler2D u_texture;\\n         \\n        void main() {\\n           gl_FragColor = texture2D(u_texture, v_texcoord);\\n        }\\n    \";","map":{"mappings":[{"source":"..\\src\\shaders.ts","name":null,"original":{"line":1,"column":0},"generated":{"line":6,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":2,"column":7},"generated":{"line":7,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":2,"column":13},"generated":{"line":7,"column":4}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":2,"column":7},"generated":{"line":7,"column":3106}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":82,"column":0},"generated":{"line":8,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":83,"column":7},"generated":{"line":9,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":83,"column":13},"generated":{"line":9,"column":4}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":83,"column":7},"generated":{"line":9,"column":227}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":93,"column":7},"generated":{"line":10,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":93,"column":13},"generated":{"line":10,"column":4}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":93,"column":7},"generated":{"line":10,"column":389}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":110,"column":7},"generated":{"line":11,"column":0}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":110,"column":13},"generated":{"line":11,"column":4}},{"source":"..\\src\\shaders.ts","name":null,"original":{"line":110,"column":7},"generated":{"line":11,"column":347}}],"sources":{"..\\src\\shaders.ts":"// Vertex shader program\r\nexport const vsSource = `\r\n    attribute vec4 a_position;\r\n    attribute vec4 a_normal;\r\n                   \r\n    // We can't pass 5x5 homogenous matrices to the shader, but can pass 4x4,\r\n    // non-homogenous matrices, then translate separately.\r\n    uniform mat4 u_model;\r\n    uniform mat4 u_view;\r\n    uniform mat4 u_proj;\r\n    \r\n    uniform vec4 u_shape_position;\r\n    uniform vec4 u_cam_position;\r\n    uniform vec4 u_ambient_light_color;\r\n    uniform vec4 u_diffuse_light_color;\r\n    uniform vec4 u_diffuse_light_direction;\r\n    \r\n    uniform float u_ambient_intensity;\r\n    uniform float u_specular_intensity;\r\n    uniform float u_color_max;\r\n           \r\n    varying vec4 v_fourd_color;\r\n    varying vec4 v_diffuse;\r\n    varying vec4 v_specular;\r\n\r\n    void main() {\r\n        // For model transform, position after the transform\r\n        vec4 positionedPt = (u_model * a_position) + u_shape_position;\r\n        // for view transform, position first.\r\n        positionedPt = u_view * (positionedPt - u_cam_position);\r\n        \r\n        // Now remove the u coord; replace with 1. We no longer need it, \r\n        // and the projection matrix is set up for 3d homogenous vectors.\r\n        vec4 positioned3d = vec4(positionedPt[0], positionedPt[1], positionedPt[2], 1.);\r\n        \r\n        gl_Position = u_proj * positioned3d;\r\n      \r\n      \r\n        // Now calculate the color, based on passed u dist from cam.\r\n        float u_dist = u_cam_position[3] - positionedPt[3];\r\n        \r\n        float portion_through = abs(u_dist) / u_color_max;\r\n\r\n        if (portion_through > 1.) {\r\n            portion_through = 1.;\r\n        }\r\n        \r\n        float base_gray = 0.0;\r\n        float color_val = base_gray + portion_through;\r\n        \r\n        vec4 f_color;\r\n        if (u_dist > 0.) {\r\n            f_color = vec4(base_gray, base_gray, color_val, 0.2);  // Blue\r\n        } else {\r\n            f_color = vec4(color_val, base_gray, base_gray, 0.2);  // Red\r\n        }\r\n        \r\n        vec4 v_fourd_color = f_color * u_ambient_intensity;\r\n        \r\n        // Process diffuse lighting from a single-directional source.\r\n        // We can use the model matrix directly on the normal, since it\r\n        // only scales uniformly, and isn't homogenous (doesn't translate).\r\n        vec4 norm = normalize(u_model * a_normal);\r\n        vec4 dir = normalize(u_diffuse_light_direction);\r\n        float directional_light_weight = max(dot(norm, dir), 0.);\r\n\r\n        v_diffuse = u_diffuse_light_color * directional_light_weight;\r\n\r\n        v_specular = vec4(0., 0., 0., 0.);  // todo\r\n\r\n//         // Now calculate specular lighting.\r\n//         // todo deal with view trasnforms.\r\n//         vec4 view_dir = normalize(u_cam_position - a_position);\r\n// //        vec4 view_dir = normalize(uview * (u_cam_position - a_position));\r\n//         vec4 reflect_dir = reflect(-dir, norm);\r\n// //        vec4 reflect_dir = u_view * reflect(-dir, norm);\r\n//         float spec = pow(max(dot(view_dir, reflect_dir), 0.), 32.);\r\n//         v_specular = u_specular_intensity * spec * u_diffuse_light_color;\r\n    }\r\n`\r\n\r\n// Fragment shader program\r\nexport const fsSource = `\r\n    varying highp vec4 v_fourd_color;\r\n    varying highp vec4 v_diffuse;\r\n    varying highp vec4 v_specular;\r\n\r\n    void main() {\r\n        gl_FragColor = v_fourd_color + v_diffuse;\r\n    }\r\n`\r\n\r\nexport const vsSkybox = `\r\n    attribute vec4 a_position;\r\n    attribute vec2 a_texcoord;\r\n     \r\n    uniform mat4 u_matrix;\r\n     \r\n    varying vec2 v_texcoord;\r\n     \r\n    void main() {\r\n      // Multiply the position by the matrix.\r\n      gl_Position = u_matrix * a_position;\r\n     \r\n      // Pass the texcoord to the fragment shader.\r\n      v_texcoord = a_texcoord;\r\n    }\r\n`\r\n\r\nexport const fsSkybox = `\r\n        precision mediump float;\r\n         \r\n        // Passed in from the vertex shader.\r\n        varying vec2 v_texcoord;\r\n         \r\n        // The texture.\r\n        uniform sampler2D u_texture;\r\n         \r\n        void main() {\r\n           gl_FragColor = texture2D(u_texture, v_texcoord);\r\n        }\r\n    `"},"lineCount":null}},"hash":"49e4fabbb85b1a5edc1098469dbf4442","cacheData":{"env":{}},"id":305}